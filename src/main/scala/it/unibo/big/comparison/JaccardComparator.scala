package it.unibo.big.comparison

object JaccardComparator {

  val ELEMENT_SEPARATOR = ";"

  private def containsSet(setArray:Array[Set[String]], element:Set[String]):Boolean = {
    setArray.exists(s => s.intersect(element).size == s.size && s.size == element.size)
  }

  def getExclusiveSetElements(baseIterableArray:Array[Set[String]],
                              otherIterableArray:Array[Set[String]]) = {
    val intersectionElement = baseIterableArray.filter(itemsetIterable => {
      otherIterableArray.exists(otherItemsetIterable => {
        otherItemsetIterable.intersect(itemsetIterable).size ==
          otherItemsetIterable.size &&
          otherItemsetIterable.size ==
            itemsetIterable.size
      })
    })
    baseIterableArray.filterNot(containsSet(intersectionElement,_))
  }

  def computeJaccardOnlyOnItemsetElements(baseIterableArray:Array[Set[String]],
                          otherIterableArray:Array[Set[String]]):Float = {
    val intersectionSize = baseIterableArray.count(itemsetIterable => {
      otherIterableArray.exists(otherItemsetIterable => {
       otherItemsetIterable.intersect(itemsetIterable).size ==
        otherItemsetIterable.size &&
        otherItemsetIterable.size ==
        itemsetIterable.size
      })
    }).toFloat

    val unionSize = (baseIterableArray.length +
    otherIterableArray.count(itemset => !baseIterableArray.exists(baseitemset => baseitemset.intersect(itemset).size == baseitemset.size &&
    baseitemset.size == itemset.size))).toFloat
    intersectionSize / unionSize
  }

  /**
   * Compute Jaccard distance on two list of strings.
   * @param baseSet the first list of strings.
   * @param otherSet the second list of strings.
   * @return a value between 0 and 1, 0 if no element in common is found, 1 if the lists contain the same elements.
   */
  def computeJaccardIndex(baseSet:Set[String], otherSet:Set[String]):Float = {
    val intersectionSize = baseSet.count(otherSet(_)).toFloat
    val unionSize = (baseSet ++ otherSet).size.toFloat
    intersectionSize / unionSize
  }

  /**
   * Given two arrays of cluster compute the pattern in the first that can't be generated by the second.
   * @param datasetToScan the dataset that will be scanned.
   * @param maximalDataset the dataset which contains the large tuples.
   * @return a Float containing the percentage of generable pattern in the first dataset inside the second.
   */
  def computeSubPattern(datasetToScan:Array[Set[String]], maximalDataset:Array[Set[String]]):Float = {
    if(maximalDataset.length == 0) {
      0
    } else {
      datasetToScan.count(cluster => {
        maximalDataset.exists(othercluster => cluster.forall(othercluster.contains))
      }).toFloat / datasetToScan.length.toFloat
    }
  }
}
